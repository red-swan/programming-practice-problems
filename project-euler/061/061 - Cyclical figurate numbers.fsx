(*
Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are
all figurate (polygonal) numbers and are generated by the following formulae:

Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
Square	 	    P4,n=n2	 	        1, 4, 9, 16, 25, ...
Pentagonal	 	P5,n=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
Hexagonal	 	P6,n=n(2n−1)	 	1, 6, 15, 28, 45, ...
Heptagonal	 	P7,n=n(5n−3)/2	 	1, 7, 18, 34, 55, ...
Octagonal	 	P8,n=n(3n−2)	 	1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three 
interesting properties.

The set is cyclic, in that the last two digits of each number is the first two 
digits of the next number (including the last number with the first).
Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal 
(P5,44=2882), is represented by a different number in the set.
This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which 
each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and 
octagonal, is represented by a different number in the set.
*)

#I "../fsharp-lib"
#load "HigherOrder.fsx"
#load "Combinatorics.fsx"

open HigherOrder
open Combinatorics

let polygonalNumbers s = 
    Seq.initInfinite (fun idx -> ((pown (idx+1) 2) * (s-2) - (idx+1)*(s-4))/2)

let polygonalCandidates s = 
    s
    |> polygonalNumbers
    |> Seq.skipWhile (fun x -> x <= 999)
    |> Seq.takeWhile (fun x -> x <= 9999)
    |> Seq.cache

let sharesDigits xxvv vvyy = 
    (xxvv / 100) = (vvyy % 100)

let isCyclical intSeq = 
    (Seq.append intSeq (Seq.take 1 intSeq))
    |> Seq.pairwise 
    |> Seq.fold (fun acc (num1,num2) -> acc & (sharesDigits num1 num2)) true

// Imperative way --------------------------------------------------------------
let candidates [first;second;third;fourth;fifth;sixth] = 
    seq { for i in first do
          for j in second do
          if sharesDigits i j then
              for k in third do
              if sharesDigits j k then 
                  for l in fourth do
                  if sharesDigits k l then
                      for m in fifth do
                      if sharesDigits l m then
                          for n in sixth do
                          if (sharesDigits m n) && (sharesDigits n i) then
                                yield [i;j;k;l;m;n]
          }
let answerImperative = 
    (permutations 6 [3 .. 8])
    |> Seq.map (fun x -> List.map polygonalCandidates x)
    |> Seq.map candidates
    |> Seq.find (fun x -> x |> Seq.isEmpty |> not)
    |> Seq.item 0 //[8256; 2882; 8128; 1281; 2512; 5625]
    |> Seq.sum
    // 0.035 sec

// Functional way --------------------------------------------------------------


// Return a list rotated until it's minimum element is the head
let canonicalCyclicPermutation (permutationList : 'a list) = 
    let min = Seq.min permutationList
    let rec loop ourList = 
        match ourList with
        | head :: tail when head = min -> ourList
        | head :: tail -> loop (tail @ [head])
    loop permutationList

// Return a list of all permutations of a list that is rotationally/cylically unique
let permutateCycUniq seedList = 
    permute seedList
    |> List.distinctBy canonicalCyclicPermutation

// Create the polygonal numbers as a list not seq
let polygonalCandidatesL s = 
    polygonalCandidates s
    |> Seq.toList

// Returns an empty list if the candidate number does not share digits
// with the list head, otherwise returns the list with the candidate at the head
let addCandidateToSolution (solution : int list) (number : int) =
    match solution with
    | (head::tail) when sharesDigits number head -> number::head::tail
    | _ -> []

// Returns a sequence of all valid solutions generated by trying to add
// a sequence of candidates to all solutions in a sequence
let addCandidatesToSolution (solutions : int list seq) (candidates : int seq) =
    Seq.collect (fun solution -> 
                 Seq.map (fun candidate -> 
                          addCandidateToSolution solution candidate)
                          candidates
                |> Seq.filter (not << List.isEmpty)) 
              solutions

// Given a list of side lengths, we return a sequence of cyclical solutions
// from the polygonal number families in the order they appear in the list
let generateSolutionsFromPolygonalFamilies (seedList : int list) = 
    let solutionSeeds = 
        seedList 
        |> List.head
        |> polygonalCandidates
        |> Seq.map (fun x -> [x])

    let solutions = 
        Seq.fold (fun acc elem -> (addCandidatesToSolution acc elem)) 
                 solutionSeeds 
                 ((List.tail seedList) |> List.map polygonalCandidatesL)
        |> Seq.filter isCyclical
    solutions

// Find all cyclical sequences from a list of polygonal number families
let FindSolutionsFromFamilies intList = 
    intList
    |> permutateCycUniq
    |> Seq.collect generateSolutionsFromPolygonalFamilies
    |> Seq.toList

// Given in the problem
let sampleAnswer = FindSolutionsFromFamilies [3;4;5]

// The set of answers that answers the problem
let problemAnswer = FindSolutionsFromFamilies [3 .. 8]
// 0.09s wow!






















